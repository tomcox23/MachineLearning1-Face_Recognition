#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.26
#  in conjunction with Tcl version 8.6
#    Nov 10, 2019 11:52:31 PM +1300  platform: Windows NT

import sys
import sys
import cv2
import os
import shutil
import numpy as np
import PIL.Image 
from tkinter import *
import json
import socket

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import guiV2_support

TCP_IP = '127.0.0.1'
TCP_PORT = 5005
BUFFER_SIZE = 1024
MESSAGE = "hello"
DISCON = "Client disconnected"

user_dict = {

}

try:
    with open('users.json', 'r') as f:
        user_dict = json.loads(f.read())
    
except:
    print("An exception occurred")  

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = Toplevel1 (root)
    guiV2_support.init(root, top)
    root.mainloop()
    w = None
    

def create_Toplevel1(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = tk.Toplevel (root)
    top = Toplevel1 (w)
    guiV2_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_Toplevel1():
    global w
    w.destroy()
    w = None
    
    
def addFace(self):
    
    name = self.Text1.get("1.0", 'end-1c') 

    if not user_dict:
        id_number = 1
    else:
        id_number = int(list(user_dict.keys())[-1])+1
        
    print("id number at start ",id_number)
    path = os.path.dirname(os.path.abspath(__file__))
    cam = cv2.VideoCapture(cv2.CAP_DSHOW)
    detector=cv2.CascadeClassifier(path+r'\Classifiers\face.xml')
    i=0
    offset=50
    
    try:
        os.mkdir("dataSetFolders/"+str(id_number)) # make directory dataSetFolders/
        print("id number mkdir",id_number)
    except:
        print("dataSetFolder already exists error")
        print("id number mkdir except ",id_number)
        
    user_dict[str(id_number)] = name
        
    j = json.dumps(user_dict) # j is now a string containing the data from dict in the json format.
    with open('users.json', 'w') as f:
        f.write(j)
    
    print(user_dict)

    
    try:
        while True:
            
            
            ret, im=cam.read()  # Read the video frame
            #take 21 images of a persons face and save images
            if(im is not None):
                gray=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY) # Convert the captured frame into grayscale
                faces=detector.detectMultiScale(gray, scaleFactor=1.2, minNeighbors=5, minSize=(100, 100), flags=cv2.CASCADE_SCALE_IMAGE) # Get all faces from the video frame
                cv2.imshow('im',im)
                
                for(x,y,w,h) in faces:
                    i+=1
                    cv2.imwrite("dataSet/face-"+str(id_number) +'.'+ str(i) + ".jpg", gray[y-offset:y+h+offset,x-offset:x+w+offset]) #save images to dataset folder for the trainer script to access
                    cv2.imwrite("dataSetFolders/"+str(id_number)+"/face-"+str(id_number) +'.'+ str(i) + ".jpg", gray[y-offset:y+h+offset,x-offset:x+w+offset]) # save images to individual folders for each person, this is for image backups 
                    cv2.rectangle(im,(x-offset,y-offset),(x+w+offset,y+h+offset),(225,0,0),2)
                    cv2.imshow('im',im[y-offset:y+h+offset,x-offset:x+w+offset])
                    cv2.waitKey(100)
                
                    if i>20:
                        cam.release()
                        cv2.destroyWindow('im')
                        print("Successfully taken photos set id number is ",id_number)
                        id_number += 1                        

                    break
                    

            else:  
                break
    except:  
        print("An error occurred. Try moving your face back from the camera")
        shutil.rmtree("dataSetFolders/"+str(id_number)) # removes directory dataSetFolders/
        del user_dict[str(id_number)]
        print(user_dict)

        
        
def train():
    path = os.path.dirname(os.path.abspath(__file__))
    recognizer = cv2.face.LBPHFaceRecognizer_create()
    cascadePath = path+r"\Classifiers\face.xml"
    faceCascade = cv2.CascadeClassifier(cascadePath);
    dataPath = path+r'\dataSet'

    
    def get_images_and_labels(datapath):
        image_paths = [os.path.join(datapath, f) for f in os.listdir(datapath)]
        # images will contain face images
        images = []
        # labels will contain the label that is assigned to the image
        labels = []
        for image_path in image_paths:
            # Read the image and convert to grayscale
            image_pil = PIL.Image.open(image_path).convert('L')
            # Convert the image format into numpy array
            image = np.array(image_pil, 'uint8')
            # Get the label of the image
            nbr = int(os.path.split(image_path)[1].split(".")[0].replace("face-", ""))
            print(nbr)
            # Detect the face in the image
            faces = faceCascade.detectMultiScale(image)
            # If face is detected, append the face to images and the label to labels
            for (x, y, w, h) in faces:
                images.append(image[y: y + h, x: x + w])
                labels.append(nbr)
                cv2.imshow("Adding faces to traning set...", image[y: y + h, x: x + w])
                cv2.waitKey(10)
        # return the images list and labels list
        return images, labels
    images, labels = get_images_and_labels(dataPath)
    cv2.imshow('Training...',images[0])
    cv2.waitKey(1)

    recognizer.train(images, np.array(labels))
    recognizer.save(path+r'\trainer\trainer.yml')
    cv2.destroyAllWindows()        


def detector():
    path = os.path.dirname(os.path.abspath(__file__))
    # Create Local Binary Patterns Histograms for face recognization
    recognizer = cv2.face.LBPHFaceRecognizer_create()
    # Load the trained mode
    recognizer.read(path+r'\trainer\trainer.yml')
    # Load prebuilt model for Frontal Face
    cascadePath = path+"\\Classifiers\\face.xml"
    # Create classifier from prebuilt model
    faceCascade = cv2.CascadeClassifier(cascadePath);

    # Initialize and start the video frame capture
    cam = cv2.VideoCapture(cv2.CAP_DSHOW)

    # Set the font style
    fontFace = cv2.FONT_HERSHEY_SIMPLEX  #Creates a font
    fontScale = 1 
    fontColor = (255, 255, 255)    
    
    try:
        connected = False
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP socket
        s.connect((TCP_IP, TCP_PORT))
        print("connected to external server")
        connected = True
    except:
        connected = False
        print("could not connect to a server")
        
    try:
        while True:
            
            ret, im =cam.read()    # Read the video frame
            gray=cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)     # Convert the captured frame into grayscale
            faces=faceCascade.detectMultiScale(gray, scaleFactor=1.2, minNeighbors=5, minSize=(100, 100), flags=cv2.CASCADE_SCALE_IMAGE) # Get all faces from the video frame
            
            # For each face in faces
            for(x,y,w,h) in faces:
                nbr_predicted, conf = recognizer.predict(gray[y:y+h,x:x+w])  # Recognize the face belongs to which id_number
                cv2.rectangle(im,(x-50,y-85),(x+w+50,y+h+50),(225,0,0),1) # Create rectangle around the face
                
                if str(nbr_predicted) in user_dict:
                    nbr_predicted = user_dict[str(nbr_predicted)] # match video person shown in video from the user data base

                else:
                    nbr_predicted = "unknown"

                
            cv2.putText(im,str(nbr_predicted)+str(''), (x+50,y+h+30),fontFace, 1.1, (0,255,0)) #Draw the text Saying who is in the video
            cv2.imshow('Face Detector',im)
            
            #send data of who is in video stream if there is a working connection
            if connected is True:
               
                try:                    
                    s.send(nbr_predicted.encode('utf-8')) # send name of person to server  
                except:
                    pass
        
            # If 'q' is pressed, close window
            if cv2.waitKey(2) & 0xFF == ord('q'):
            
                if connected is True:
                    s.send(DISCON.encode('utf-8')) # send server the disconnection message to tell it to shut off                
                    s.close() # close connection of the socket
                    print("disconnected from server")
                    
                break

            
        # Stop the camera
        cam.release()
    
        # Close all windows
        cv2.destroyAllWindows()
        
    except:
        # error messages for why the camera wont turn on
        print("No faces detected in frame.")
        print("Make sure you are in-front of the camera")
    
    # exit program method
def Exit():
    quit()

    # call user list to be able to delete users
def deleteUser():
    lbt=ListUserBox()  

    # create and set all gui parameters
class Toplevel1:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        font10 = "-family {Segoe UI} -size 10 -weight bold -slant "  \
            "roman -underline 0 -overstrike 0"
        font9 = "-family {Segoe UI} -size 12 -weight bold -slant roman"  \
            " -underline 0 -overstrike 0"
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.',background=_bgcolor)
        self.style.configure('.',foreground=_fgcolor)
        self.style.configure('.',font="TkDefaultFont")
        self.style.map('.',background=
            [('selected', _compcolor), ('active',_ana2color)])

        top.geometry("600x400+525+231")
        top.minsize(120, 1)
        top.maxsize(5124, 1421)
        top.resizable(1, 1)
        top.title("Facial Recognition Menu")
        top.configure(background="#202020")
        
        # create add face button
        self.ButtonAddface = tk.Button(top, command= lambda: addFace(self)) # sets button click event. calls addFace method
        self.ButtonAddface.place(relx=0.167, rely=0.375, height=54, width=117)
        self.ButtonAddface.configure(activebackground="#ececec")
        self.ButtonAddface.configure(activeforeground="#000000")
        self.ButtonAddface.configure(background="#d9d9d9")
        self.ButtonAddface.configure(disabledforeground="#a3a3a3")
        self.ButtonAddface.configure(font=font10)
        self.ButtonAddface.configure(foreground="#000000")
        self.ButtonAddface.configure(highlightbackground="#d9d9d9")
        self.ButtonAddface.configure(highlightcolor="black")
        self.ButtonAddface.configure(pady="0")
        self.ButtonAddface.configure(text='''Add a Face''')

        # create add train
        self.ButtonTrain = tk.Button(top, command=train) # sets button click event. calls train method
        self.ButtonTrain.place(relx=0.417, rely=0.375, height=54, width=117)
        self.ButtonTrain.configure(activebackground="#ececec")
        self.ButtonTrain.configure(activeforeground="#000000")
        self.ButtonTrain.configure(background="#d9d9d9")
        self.ButtonTrain.configure(disabledforeground="#a3a3a3")
        self.ButtonTrain.configure(font=font10)
        self.ButtonTrain.configure(foreground="#000000")
        self.ButtonTrain.configure(highlightbackground="#d9d9d9")
        self.ButtonTrain.configure(highlightcolor="black")
        self.ButtonTrain.configure(pady="0")
        self.ButtonTrain.configure(text='''Train''')

        # create detector button
        self.ButtonDetect = tk.Button(top, command=detector) # sets button click event. calls detector method
        self.ButtonDetect.place(relx=0.667, rely=0.375, height=54, width=117)
        self.ButtonDetect.configure(activebackground="#ececec")
        self.ButtonDetect.configure(activeforeground="#000000")
        self.ButtonDetect.configure(background="#d9d9d9")
        self.ButtonDetect.configure(disabledforeground="#a3a3a3")
        self.ButtonDetect.configure(font=font10)
        self.ButtonDetect.configure(foreground="#000000")
        self.ButtonDetect.configure(highlightbackground="#d9d9d9")
        self.ButtonDetect.configure(highlightcolor="black")
        self.ButtonDetect.configure(pady="0")
        self.ButtonDetect.configure(text='''Detect''')

        # create user list button
        self.ButtonUserList = tk.Button(top, command=deleteUser) # sets button click event. calls deleteuser method
        self.ButtonUserList.place(relx=0.167, rely=0.625, height=54, width=117)
        self.ButtonUserList.configure(activebackground="#ececec")
        self.ButtonUserList.configure(activeforeground="#000000")
        self.ButtonUserList.configure(background="#d9d9d9")
        self.ButtonUserList.configure(disabledforeground="#a3a3a3")
        self.ButtonUserList.configure(font=font10)
        self.ButtonUserList.configure(foreground="#000000")
        self.ButtonUserList.configure(highlightbackground="#d9d9d9")
        self.ButtonUserList.configure(highlightcolor="black")
        self.ButtonUserList.configure(pady="0")
        self.ButtonUserList.configure(text='''User List''')

        # create enter name text box
        self.Text1 = tk.Text(top)
        self.Text1.place(relx=0.167, rely=0.2, relheight=0.11, relwidth=0.24)
        self.Text1.configure(background="white")
        self.Text1.configure(font="TkTextFont")
        self.Text1.configure(foreground="black")
        self.Text1.configure(highlightbackground="#d9d9d9")
        self.Text1.configure(highlightcolor="black")
        self.Text1.configure(insertbackground="black")
        self.Text1.configure(selectbackground="#c4c4c4")
        self.Text1.configure(selectforeground="black")
        self.Text1.configure(wrap="word")
    
        self.TLabel1 = ttk.Label(top)
        self.TLabel1.place(relx=0.167, rely=0.125, height=29, width=95)
        self.TLabel1.configure(background="#202020")
        self.TLabel1.configure(foreground="#fdfdfd")
        self.TLabel1.configure(font=font9)
        self.TLabel1.configure(relief="flat")
        self.TLabel1.configure(text='''Enter Name''')

        # create exit button
        self.ButtonExit = tk.Button(top, command=Exit) # sets button click event. calls Exit method
        self.ButtonExit.place(relx=0.417, rely=0.625, height=54, width=117)
        self.ButtonExit.configure(activebackground="#ececec")
        self.ButtonExit.configure(activeforeground="#000000")
        self.ButtonExit.configure(background="#d9d9d9")
        self.ButtonExit.configure(disabledforeground="#a3a3a3")
        self.ButtonExit.configure(font=font10)
        self.ButtonExit.configure(foreground="#000000")
        self.ButtonExit.configure(highlightbackground="#d9d9d9")
        self.ButtonExit.configure(highlightcolor="black")
        self.ButtonExit.configure(pady="0")
        self.ButtonExit.configure(text='''Exit''')

        self.menubar = tk.Menu(top,font="TkMenuFont",bg=_bgcolor,fg=_fgcolor)
        top.configure(menu = self.menubar)

    # class to make a user list    
class ListUserBox :
    def __init__(self) :
        self.root = Tk()
        self.list_box_1 = Listbox(self.root, width = 50, selectmode=EXTENDED)
        self.list_box_1.pack(fill = BOTH, expand=True)
        self.delete_button = Button(self.root, text="Delete",command=self.DeleteSelection)
        self.delete_button.pack()
        
        
        for key in sorted(user_dict):
            self.list_box_1.insert(END, '{}: {}'.format(key, user_dict[key]))

    # delete user from the user list, JSON file and remove all stored data for that user        
    def DeleteSelection(self) :
        items = self.list_box_1.curselection()
        pos = 0
        for i in items :
            id_number_del = self.list_box_1.get(i)
            idx = int(i) - pos
            self.list_box_1.delete( idx,idx )
            pos = pos + 1
            # get name from the user list. 
            text = str(id_number_del)
            sep = ':'
            rest = text.split(sep, 1)[0]
        
            try:
                print(id_number_del + " has been deleted")
                del user_dict[str(rest)]
                j = json.dumps(user_dict) # j is now a string containing the data from dict in the json format.
                with open('users.json', 'w') as f:
                    f.write(j)
                print(user_dict)
                shutil.rmtree("dataSetFolders/"+str(rest)) # delete images and folder of user. shutil deletes non empty directories
                f=0
                while f < 21:
                    f += 1
                    os.remove("dataSet/face-"+str(rest) +'.'+ str(f) + ".jpg") # delete all selected user images from dataset folder.
                    
                break
            except KeyError:
                print("Key not found")
            



        
if __name__ == '__main__':
    vp_start_gui()
